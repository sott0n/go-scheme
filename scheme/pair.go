// Pair is a type which is generated by cons procedure.
// Pair has two pointers, which are named car and cdr.
//
// List is expressed by linked of Pair.
// And procedure application has list which consists of Pair.
// as its arguments.

package scheme

import (
	"fmt"
	"log"
	"strings"
)

// Pair is a struction for car and cdr.
type Pair struct {
	ObjectBase
	Car         Object
	Cdr         *Pair
	environment *Environment
}

// Eval is Pair's eval IF.
func (p *Pair) Eval() Object {
	return p
}

// String is a string function with accessing Pair.
func (p *Pair) String() string {
	if p.IsEmpty() {
		return "()"
	} else if p.IsList() {
		length := p.ListLength()
		tokens := []string{}
		for i := 0; i < length; i++ {
			tokens = append(tokens, p.ElementAt(i).Eval().String())
		}
		return fmt.Sprintf("(%s)", strings.Join(tokens, " "))
	} else {
		return "Not implemented."
	}
}

// IsPair is checking wether is pair or not.
func (p *Pair) IsPair() bool {
	return true
}

// IsList is checking ehther is list or not
func (p *Pair) IsList() bool {
	pair := p
	for {
		if pair.IsEmpty() {
			return true
		}
		pair = pair.Cdr
	}
}

// ElementAt is searching procedure in element of list.
func (p *Pair) ElementAt(index int) Object {
	if !p.IsList() {
		log.Fatal("ElementAt() was called for not list object.")
	} else if index < 0 {
		log.Fatal("ElementAt() was called with negative index.")
	}
	pair := p
	for {
		if index == 0 {
			return pair.Car
		}
		pair = pair.Cdr
		index--
	}
}

// IsEmpty is checking empty value.
func (p *Pair) IsEmpty() bool {
	return p.Car == nil && p.Cdr == nil
}

// ListLength returns length of list.
func (p *Pair) ListLength() int {
	if p.IsEmpty() {
		return 0
	}
	return p.Cdr.ListLength() + 1
}
